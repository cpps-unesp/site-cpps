name: "Dependabot: Close Superseded"

on:
  pull_request:
    types: [opened, reopened, synchronize]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "Dependabot PR number to evaluate"
        required: true
        type: string

permissions:
  pull-requests: write

jobs:
  dependabot-close-superseded:
    if: github.actor == 'dependabot[bot]' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Close older Dependabot PRs
        uses: actions/github-script@v7
        with:
          script: |
            const prNumberInput = context.payload.inputs?.pr_number;
            const current = prNumberInput
              ? (await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: Number(prNumberInput),
                })).data
              : context.payload.pull_request;
            const title = current.title || '';
            const match = title.match(/^Bump\s+(.+?)\s+from\s+(.+?)\s+to\s+(.+)$/i);
            if (!match) {
              core.info('Title did not match Dependabot bump format.');
              return;
            }

            const depName = match[1];
            const currentNew = match[3];

            const compareVersions = (a, b) => {
              const norm = (v) => v.replace(/^v/, '').split('.').map((n) => parseInt(n, 10));
              const av = norm(a);
              const bv = norm(b);
              const len = Math.max(av.length, bv.length);
              for (let i = 0; i < len; i += 1) {
                const ai = Number.isFinite(av[i]) ? av[i] : 0;
                const bi = Number.isFinite(bv[i]) ? bv[i] : 0;
                if (ai > bi) return 1;
                if (ai < bi) return -1;
              }
              return 0;
            };

            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100,
            });

            const related = pulls.filter((pr) => {
              if (pr.number === current.number) return false;
              if (pr.user?.login !== 'dependabot[bot]') return false;
              const m = pr.title?.match(/^Bump\s+(.+?)\s+from\s+(.+?)\s+to\s+(.+)$/i);
              return m && m[1] === depName;
            });

            if (related.length === 0) {
              core.info('No related Dependabot PRs found.');
              return;
            }

            const currentIsNewest = related.every((pr) => {
              const m = pr.title.match(/^Bump\s+(.+?)\s+from\s+(.+?)\s+to\s+(.+)$/i);
              const otherNew = m ? m[3] : '';
              return compareVersions(currentNew, otherNew) >= 0;
            });

            if (!currentIsNewest) {
              core.info('Current PR is not the newest; leaving others open.');
              return;
            }

            for (const pr of related) {
              const m = pr.title.match(/^Bump\s+(.+?)\s+from\s+(.+?)\s+to\s+(.+)$/i);
              const otherNew = m ? m[3] : '';
              if (compareVersions(currentNew, otherNew) > 0) {
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  state: 'closed',
                });
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: `Closing as superseded by #${current.number} (${depName} ${currentNew}).`,
                });
              }
            }
