name: Merge Guard

on:
  pull_request:

permissions:
  checks: read
  pull-requests: read

jobs:
  validate:
    if: github.event.pull_request.base.ref == 'main'
    runs-on: ubuntu-latest
    name: Validate PR Checks
    steps:
      - name: Wait for all checks to complete
        uses: actions/github-script@v7
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const maxAttempts = 60; // 60 tentativas x 5s = 5 minutos max
            const delaySeconds = 5;
            const ignoredChecks = ['Merge Guard', 'Validate PR Checks', 'Cloudflare Pages'];

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const { data } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha,
                filter: 'latest',
                per_page: 100,
              });
              
              const checkRuns = data.check_runs.filter(
                run => !ignoredChecks.includes(run.name)
              );

              if (checkRuns.length === 0) {
                core.info(`‚è≥ Attempt ${attempt}/${maxAttempts}: No checks found yet...`);
                await new Promise(r => setTimeout(r, delaySeconds * 1000));
                continue;
              }

              // Verificar status de todos os checks
              const completed = checkRuns.filter(run => run.status === 'completed');
              const inProgress = checkRuns.filter(run => run.status !== 'completed');

              // Considerar 'skipped' como sucesso para n√£o bloquear o merge guard
              const failed = completed.filter(run =>
                run.conclusion !== 'success' &&
                run.conclusion !== 'neutral' &&
                run.conclusion !== 'skipped'
              );

              // Log de progresso a cada 10 tentativas
              if (attempt % 10 === 0 || attempt === 1) {
                core.info(`\nüìä Status (attempt ${attempt}/${maxAttempts}):`);
                core.info(`   Total checks: ${checkRuns.length}`);
                core.info(`   ‚úÖ Completed: ${completed.length}`);
                core.info(`   ‚è≥ In progress: ${inProgress.length}`);
                core.info(`   ‚ùå Failed: ${failed.length}`);

                if (inProgress.length > 0) {
                  core.info(`   Running: ${inProgress.map(r => r.name).join(', ')}`);
                }
              }

              // Se h√° falhas reais, falhar imediatamente
              if (failed.length > 0) {
                const failedNames = failed.map(r => `${r.name} (${r.conclusion})`).join(', ');
                core.setFailed(`‚ùå Checks failed: ${failedNames}`);
                return;
              }

              // Se todos completaram com sucesso (ou neutral/skipped)
              if (completed.length === checkRuns.length) {
                core.info(`\n‚úÖ All ${checkRuns.length} checks passed (or were skipped)!`);
                return;
              }

              // Aguardar pr√≥xima tentativa
              await new Promise(r => setTimeout(r, delaySeconds * 1000));
            }

            core.setFailed('‚è∞ Timeout waiting for checks to complete (5 minutes)');
